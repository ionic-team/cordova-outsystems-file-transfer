// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios14.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name IONFileTransferLib
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import Combine
import Foundation
import Swift
import UniformTypeIdentifiers
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public enum IONFLTRException : Swift.Error, Swift.CustomStringConvertible {
  case invalidPath(path: Swift.String?)
  case emptyURL(url: Swift.String?)
  case invalidURL(url: Swift.String)
  case fileDoesNotExist(cause: (any Swift.Error)?)
  case cannotCreateDirectory(path: Swift.String, cause: (any Swift.Error)?)
  case httpError(responseCode: Swift.Int, responseBody: Swift.String?, headers: [Swift.String : Swift.String]?)
  case connectionError(cause: (any Swift.Error)?)
  case transferError(cause: (any Swift.Error)?)
  case unknownError(cause: (any Swift.Error)?)
  public var description: Swift.String {
    get
  }
}
extension IONFileTransferLib.IONFLTRException : Swift.Equatable {
  public static func == (lhs: IONFileTransferLib.IONFLTRException, rhs: IONFileTransferLib.IONFLTRException) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class IONFLTRManager : ObjectiveC.NSObject {
  @objc override dynamic public init()
  public func downloadFile(fromServerURL serverURL: Foundation.URL, toFileURL fileURL: Foundation.URL, withHttpOptions httpOptions: IONFileTransferLib.IONFLTRHttpOptions) throws -> IONFileTransferLib.IONFLTRPublisher
  public func uploadFile(fromFileURL fileURL: Foundation.URL, toServerURL serverURL: Foundation.URL, withUploadOptions uploadOptions: IONFileTransferLib.IONFLTRUploadOptions, andHttpOptions httpOptions: IONFileTransferLib.IONFLTRHttpOptions) throws -> IONFileTransferLib.IONFLTRPublisher
  @objc deinit
}
@_hasMissingDesignatedInitializers public class IONFLTRPublisher : Combine.Publisher {
  public typealias Output = IONFileTransferLib.IONFLTRTransferResult
  public typealias Failure = Swift.Error
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == any Swift.Error, S.Input == IONFileTransferLib.IONFLTRTransferResult
  @objc deinit
}
public typealias HttpParams = [Swift.String : [Swift.String]]
public typealias HttpHeaders = [Swift.String : Swift.String]
public struct IONFLTRHttpOptions {
  public init(method: Swift.String, params: IONFileTransferLib.HttpParams = [:], headers: IONFileTransferLib.HttpHeaders = [:], timeout: Swift.Int = 60, disableRedirects: Swift.Bool = false, shouldEncodeUrlParams: Swift.Bool = true)
}
public enum IONFLTRTransferResult : Swift.Equatable {
  case ongoing(status: IONFileTransferLib.IONFLTRProgressStatus)
  case complete(data: IONFileTransferLib.IONFLTRTransferComplete)
  public static func == (a: IONFileTransferLib.IONFLTRTransferResult, b: IONFileTransferLib.IONFLTRTransferResult) -> Swift.Bool
}
public struct IONFLTRProgressStatus : Swift.Equatable {
  public var bytes: Swift.Int
  public var contentLength: Swift.Int
  public var lengthComputable: Swift.Bool
  public static func == (a: IONFileTransferLib.IONFLTRProgressStatus, b: IONFileTransferLib.IONFLTRProgressStatus) -> Swift.Bool
}
public struct IONFLTRTransferComplete : Swift.Equatable {
  public var totalBytes: Swift.Int
  public var responseCode: Swift.Int
  public var responseBody: Swift.String?
  public var headers: [Swift.String : Swift.String]
  public static func == (a: IONFileTransferLib.IONFLTRTransferComplete, b: IONFileTransferLib.IONFLTRTransferComplete) -> Swift.Bool
}
public struct IONFLTRUploadOptions {
  public init(chunkedMode: Swift.Bool = false, mimeType: Swift.String? = nil, fileKey: Swift.String = "file", formParams: [Swift.String : Swift.String]? = nil)
}
